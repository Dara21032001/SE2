package to_do;public final class ArrayBag<T> implements BagInterface<T> {    //STEP 1: DETERMINES THE DATA FIELDS    /**     * TO-DO: Declares the necessary attributes     * bag: T[]     * numberOfEntries: int     * DEFAULT_CAPACITY: int (30)     * MAX_CAPACITY: int (3000)     */    private T[] bag;    private int numberOfEntries;    private boolean initialized = false;    private static final int DEFAULT_CAPACITY = 25;    private static final int MAX_CAPACITY = 10000;    //STEP 2: IMPLEMENTS THE CONSTRUCTORS    /**     * TO-DO: Creates an empty bag with default capacity     */    public ArrayBag() {        this(DEFAULT_CAPACITY);    }    /**     * TO-DO: Creates an empty bag having a given capacity.     *     * @param desiredCapacity The integer capacity desired.     */    public ArrayBag(int desiredCapacity) {        if (desiredCapacity <= MAX_CAPACITY) {            @SuppressWarnings("unchecked")            T[] tempBag = (T[]) new Object[desiredCapacity];            bag = tempBag;            numberOfEntries = 0;            initialized = true;        } else            throw new IllegalStateException("Attempt to create a bag " + "whose capacity exceeds " + "allowed maximum.");    }    // checkInitialization() - throws an exception    // if this object is not initialized.    private void checkInitialization() {        if (!initialized) throw new SecurityException("ArrayBag object is not initialized " + "properly.");    }    //STEP 3: IMPLEMENTS THE FUNCTIONS    /**     * TO-DO: Adds a new entry to this bag.     *     * @param newEntry The object to be added as a new entry.     * @return True if the addition is successful, or false if not.     */    public boolean add(T newEntry) {        checkInitialization();        boolean result = true;        if (isArrayFull()) {            result = false;        } else {            bag[numberOfEntries] = newEntry;            numberOfEntries++;        }        return result;    }    private boolean isArrayFull() {        return numberOfEntries >= bag.length;    }    /**     * TO-DO: Retrieves all entries that are in this bag.     *     * @return A newly allocated array of all the entries in this bag.     */    public T[] toArray() {        checkInitialization();        @SuppressWarnings("unchecked")        T[] result = (T[]) new Object[numberOfEntries];        for (int index = 0; index < numberOfEntries; index++) {            result[index] = bag[index];        }        return result;    }    /**     * TO-DO: Removes all entries from this bag.     */    public void clear() {        while (!isEmpty()) remove();    }    /**     * TO-DO: Removes one unspecified entry from this bag, if possible.     *     * @return Either the removed entry, if the removal was successful, or null.     */    public T remove() {        checkInitialization();        T result = removeEntry(numberOfEntries - 1);        return result;    }    /**     * TO-DO: Removes one occurrence of a given entry from this bag.     *     * @param anEntry The entry to be removed.     * @return True if the removal was successful, or false if not.     */    public boolean remove(T anEntry) {        checkInitialization();        int index = getIndexOf(anEntry);        T result = removeEntry(index);        return anEntry.equals(result);    }    // TO-DO: Removes and returns the entry at a given index within the array.    // If no such entry exists, returns null.    // Precondition: 0 <= givenIndex < numberOfEntries.    // Precondition: checkInitialization has been called.    private T removeEntry(int givenIndex) {        T result = null;        if (!isEmpty() && (givenIndex >= 0)) {            result = bag[givenIndex];            int lastIndex = numberOfEntries - 1;            bag[givenIndex] = bag[lastIndex];            bag[lastIndex] = null;            numberOfEntries--;        }        return result;    }    // TO-DO: Locates a given entry within the array bag.    // Returns the index of the entry, if located,    // or -1 otherwise.    // Precondition: checkInitialization has been called.    private int getIndexOf(T anEntry) {        int where = -1;        boolean found = false;        int index = 0;        while (!found && (index < numberOfEntries)) {            if (anEntry.equals(bag[index])) {                found = true;                where = index;            }            index++;        }        return where;    }    /**     * TO-DO: Removes all entries from this bag.     */    public boolean isEmpty() {        return numberOfEntries == 0;    }    /**     * TO-DO: Gets the current number of entries in this bag.     *     * @return The integer number of entries currently in this bag.     */    public int getCurrentSize() {        return numberOfEntries;    }    /**     * TO-DO: Counts the number of times a given entry appears in this bag.     *     * @param anEntry The entry to be counted.     * @return The number of times anEntry appears in this bag.     */    public int getFrequencyOf(T anEntry) {        checkInitialization();        int counter = 0;        for (int index = 0; index < numberOfEntries; index++) {            if (anEntry.equals(bag[index])) {                counter++;            }        }        return counter;    }    /**     * TO-DO: Tests whether this bag contains a given entry.     *     * @param anEntry The entry to locate.     * @return True if this bag contains anEntry, or false otherwise.     */    public boolean contains(T anEntry) {        checkInitialization();        return getIndexOf(anEntry) > -1;    }}